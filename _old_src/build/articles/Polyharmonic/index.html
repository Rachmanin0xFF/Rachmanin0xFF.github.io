<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=format-detection content="telephone=no"><meta name=HandheldFriendly content=true><meta name=MobileOptimized content=320><meta name=viewport content="initial-scale=1,width=device-width"><title>Adam Lastowka - Motivation for Polyharmonic Splines</title><meta name=description content=""><script async defer src=./../../scripts/parallax.js onload="var loaded=true;"></script><link rel=stylesheet id=lightmodehl href=./../../scripts/highlight/styles/atom-one-light.min.css><link rel=stylesheet id=darkmodehl href=./../../scripts/highlight/styles/hybrid.min.css disabled><script src=./../../scripts/highlight/highlight.min.js></script><script>hljs.highlightAll();</script><link rel=stylesheet href=./../../post.css><script defer src=./../../scripts/darkmode.js></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script type=text/x-mathjax-config>MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      processEscapes: true,
    }
  }</script><link rel=icon href=./../../favicon.ico type=image/x-icon><link rel="shortcut icon" href=./../../favicon.ico type=image/x-icon></head><body><div id=bkg><section id=not-background><section id=sidebar><div class=sticky><div class="sb-big onbkg hvr-rotate"><a href=../../index.html>Home</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../about/index.html>About</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../qa/index.html>Q&A</a></div><!--<br><br><div id="dm-toggle" class="button sb-big hvr-rotate">Lights</button>--></div></section><section id=header><div class=null><div id=spikes class=vector alt=""></div></div><div id=sitename><h5><a href=./../../index.html>Adam<br>Lastowka</a></h5></div></section><div id=foreground><section id=feed><h1>Motivation for Polyharmonic Splines</h1><div class=date>Published: Jan 6, 2025</div><div class=tags>Tagged with: <a href=./../../topics/math/index.html>math</a> <a href=./../../topics/cs/index.html>cs</a></div><br><p>I have a 9x9 grid of numbers; I only know what three of them are.</p><p>Can we guess the other numbers in the grid given these three?</p><p>...</p><p>Okay, obviously, no, we can&#39;t. We need some additional information. Maybe that information is &quot;this is a sudoku board&quot;, or &quot;everything else is just 5&quot;. I&#39;ll pick a simple-sounding rule:</p><p><strong>Every remaining number is the average of its neighbors.</strong></p><p>Where &quot;neighbors&quot; doesn&#39;t include cells on diagonals (just the four cardinal directions). This rule is great because it&#39;s really easy to solve with a computer. We just do this:</p><pre><code class=language-python>for i in range(0, iterations):
    for each cell:
        cell = average(cell_neighbors)
</code></pre><div class=imblock><img src=anim-squares1.gif class=postim></div><p>This code converges towards a solution. That is, if you want an answer where the averaging rule is true up to some precision, I can guarantee you&#39;ll get it after a number of iterations. I won&#39;t get into <em>why</em> that&#39;s true here, but it seems reasonable given the visualization above; we&#39;re smoothing out the grid of numbers, approaching a <strong>maximally smooth</strong> solution.</p><p><em>Note: I&#39;m not talking about <a href=https://en.wikipedia.org/wiki/Smoothness>smoothness</a> in the traditional mathematical sense, I mean something closer to &quot;smooth to the touch&quot;. Also, we&#39;re about to get a little mathematical, so be warned: I am not a mathematician :P (we will keep it very informal)</em></p><p>But what does &quot;maximally smooth&quot; mean? Can we define it? I&#39;ll get there, but first let&#39;s explore this algorithm a little more.</p><h3 id=stencils>Stencils</h3><p>&quot;Update cell (x, y) to be the average of its neighbors&quot; really means: $$ f_{i+1}(x, y)=\frac{1}{4}\left(f_i(x+1, y) + f_i(x-1, y) + f_i(x, y+1) + f_i(x, y-1)\right) $$ <strong>At stability</strong>, we expect that \(f_{i+1}=f_i\), so we can drop the \(i\), subtract \(f(x, y)\) from both sides, and multiply by -4: $$ 0 = 4f(x, y) - f(x+1, y) - f(x-1, y) - f(x, y+1) - f(x, y-1) $$ We can visualize this as a <a href=https://en.wikipedia.org/wiki/Stencil_(numerical_analysis)>stencil</a> for convenience:</p><div class=imblock><img src=stencil.png class=postim></div><p>If you&#39;ve worked with <a href=https://pythonnumericalmethods.studentorg.berkeley.edu/notebooks/chapter23.03-Finite-Difference-Method.html>finite difference methods</a> before, you might recognize this as the stencil for the Laplace equation, \(\Delta f=0\). That&#39;s right: $$ \textrm{&quot;Be the average of your neighbors&quot;} \approx (\textrm{Solve }\Delta f = 0) $$ If you want to know <em>why</em> this is true, you can <a href=https://mitchr.dev/2020/03/18/skewedLaplaceSquare.html>derive it</a> by taking a Taylor expansion at each node, but I also encourage you think through things before plugging in symbols. A few ideas to mull over when building intuition:</p><ol><li>Solutions to the Laplace equation are harmonic, which means they must satisfy <a href=https://en.wikipedia.org/wiki/Harmonic_function#The_mean_value_property>mean value property</a> (a continuous analog of our rule).</li><li>The second derivative of a 1D function answers the question &quot;how much am I different from the average of my neighbors?&quot; at each point.</li><li>For the 2D Laplace operator, bending up along one axis cancels bending down along the other.</li><li>The Laplace equation essentially says &quot;no local extrema allowed!&quot;</li></ol><p>Anyhow, the gist is that differential operators are ssociated with (non-unique) stencils. It turns out the little algorithm above is equivalent to solving a 9x9 discretization of the Laplace equation with the <a href=https://en.wikipedia.org/wiki/Jacobi_method>Jacobi method</a>.</p><p>Fun detour, but are solutions to the Laplace equation &quot;maximally smooth&quot;, somehow?</p><h3 id=quantifying-bending>Quantifying Bending</h3><p>Instead of thinking about maximal smoothness, let&#39;s work in terms of the equivalent property, &#39;minimal roughness&#39;. Let&#39;s also put on our generality hats and think in \(d\) dimensions.</p><p><strong>To determine how &#39;rough&#39; (not-smooth) a function is, we&#39;ll add up its derivatives.</strong> This is reasonable: smooth surfaces are flatter, rough surfaces have little grooves and kinks \(\implies\) larger derivatives. We&#39;ll use the operator \(\nabla^m\), which spits out a vector of all \(m\)th-order partial derivatives, e.g., in 2D, \(\nabla^2 f = (f_{xx},f_{xy},f_{yx},f_{yy})\) is just the elements of the Hessian. I&#39;ll call the quantity \(|\nabla^m f|^2\) the &quot;\(m\)-bending&quot; of \(f\). You can think of this quantity as &#39;local roughness&#39; if it helps. So, in 2D, the 2-bending of \(f\) is: $$ |\nabla^2 f|^2={f_{xx}}^2 + 2{f_{xy}}^2 + {f_{yy}}^2 $$ And its 1-bending is simply: $$ |\nabla f|^2={f_{x}}^2+ {f_{y}}^2 $$ We can talk about the <em>total</em> \(m\)-bending on \(f\) by integrating this value: $$ E[f]=\int_{\Omega \subset \mathbb{R}^d} |\nabla^m f|^2 d\mathbf{x} $$ Here, \(d\mathbf{x}\) is hypervolume (a bit of our region, \(\Omega\)) and \(E\) is a functional. So if some \(f\) minimizes this functional (a function of a function), we can say it has the sort of &#39;minimal roughness&#39; we were looking for.</p><h3 id=from-action-to-local-laws>From Action to Local Laws</h3><p>The <a href=https://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation>Euler-Lagrange equations</a> let us translate broad statements about maximization into concrete differential equations. Let&#39;s try using them on our bending energy functional and see what comes out. The relevant equation for our problem looks like this (the E-L equation for a single function of multiple variables with higher-order derivatives): $$ \frac{\partial E}{\partial f} - \sum_{i}^n (-1)^{|\alpha_i|}\partial^{\alpha_i}\frac{\partial F}{\partial(\partial^{\alpha_i}f)} = 0 $$ Because our Lagrangian doesn&#39;t care about lower-order derivatives of \(f\), we&#39;ll say that the multi-index \(\alpha\) <strong>only indexes</strong> \(m\)<strong>th-order partial derivatives</strong>. <a href=https://en.wikipedia.org/wiki/Multi-index_notation>Multi-index notation</a> can be intimidating if you haven&#39;t encountered it before, so I&#39;ll give a concrete example of how I&#39;m using it here. In 2D, for \(m=2\): $$ \begin{align} &amp;|\alpha|=m=2\\ &amp;\alpha_1=(2, 0),\ \alpha_2=(1, 1),\ \alpha_3=(0, 2) \\ &amp;\partial^{\alpha_1}f = \frac{\partial^2 f}{\partial x^2}\\&amp; \partial^{\alpha_2}f = \frac{\partial^2 f}{\partial x\partial y}\\&amp; \partial^{\alpha_3}f = \frac{\partial^2 f}{\partial y^2} \end{align} $$ Fun fact: the cardinality of \(\alpha\) (\(n\) in the summation above, \(n=3\) in the example immediately above) is the number of distinct \(m\)th order partial derivatives in \(d\) dimensions is a <a href=https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)>stars and bars</a> problem, and is given by: $$ n={m+d-1 \choose d-1} $$ We choose this multi-index because our bending-energy Lagrangian, \(F\), is only a function of the \(m\)th order partial derivatives of \(f\): $$ E[f] = \int_{\Omega \subset \mathbb{R}^d}F(\partial^{\alpha_1}f,\partial^{\alpha_2}f,\ldots,\partial^{\alpha_n}f)=\int_{\Omega \subset \mathbb{R}^d} |\nabla^m f|^2 d\mathbf{x} $$ Conveniently, this Lagrangian depends on \(f\)&#39;s derivatives, and not explicitly on \(f\) itself. So \(\partial F / \partial f = 0\), and we only need to find the quantity: $$ \begin{align} &amp;\sum_{i}^n(-1)^{|\alpha_i|}\partial^{\alpha_i}\frac{\partial F}{\partial (\partial^{\alpha_i}f)}\\=&amp;\sum_{i}^n(-1)^m\partial^{\alpha_i}\frac{\partial |\nabla^mf|^2}{\partial (\partial^{\alpha_i}f)}\\=&amp;2(-1)^m\sum_{i}^n(\partial^{\alpha_i})^2f\\=&amp;2(-1)^m\nabla^{2m}f\\=&amp;2(-1)^m\Delta^m f \end{align} $$ Plugging everything into the Euler-Lagrange equation from earlier, all that remains is: $$ \Delta^m f = 0 $$ So our energy-minimizing \(f\) solves a <a href=https://encyclopediaofmath.org/wiki/Poly-harmonic_function>polyharmonic equation</a>. For us, this means that if a function \(g:\mathbb{R}^2\to \mathbb{R}\) minimizes \({g_{x}}^2 + {g_{y}}^2\) integrated over its surface, then \(g\) <strong>solves the Laplace equation</strong> \(\nabla^2 g = \Delta g = 0\).</p><p>However, this does not necessarily mean that the converse is true: <strong>we still don&#39;t know if our averaging algorithm generates maximally-smooth grids!</strong></p><h3 id=trouble-at-the-boundaries>Trouble at the Boundaries</h3><p>The problem that I&#39;ve danced around until now is that I never explicitly said what happens at the <em>borders</em> of the 9x9 square: I worded the rule in a way that implied only <em>existing</em> neighbors were considered in the average. I did specify a <em>few</em> boundary conditions (the three Dirichlet points on the grid), but these don&#39;t tell you anything about the edges.</p><p>Keep in mind that I could&#39;ve used any other policy. Cells could have been surrounded by a border of fixed values (<a href=https://en.wikipedia.org/wiki/Dirichlet_boundary_condition>Dirichlet</a> bounds), restricted to be &quot;flat&quot; or &quot;sloped&quot; at the edges (<a href=https://en.wikipedia.org/wiki/Neumann_boundary_condition>Neumann</a> bounds), or any other choice from the uncountably infinite set of possible boundary conditions (BCs). Some of these boundaries will lead to very slope-y behavior, so we can say that <strong>not all BCs will lead to minimal bending</strong>.</p><p>But if we want minimal bending, which BCs do we choose?</p><p>We could just <em>search</em> the space of possible BCs. Bending is computable (and, notably, a linear function of the cell values) on the 9x9 grid; throwing an optimizer at it should work. For higher-order polyharmonics with larger stencils, you can pad the boundary with additional cells.</p><p>However, if we ask about the bending on <em>all</em> of \(\mathbb{R}^d\), there&#39;s an easier option.</p><h3 id=free-variables>Free Variables</h3><p>Let&#39;s return to the 2D Laplace equation for an illustrative example. In our case, we&#39;re looking at weakly <a href=https://en.wikipedia.org/wiki/Harmonic_function>harmonic</a> solutions with singularities at the \(N=3\) points we fixed, which I&#39;ll denote \( \mathbf{x}_1, \mathbf{x}_2, \cdots, \mathbf{x}_N \). If these are the <em>only</em> singularities we have, we expect the solution to be some linear combination of the Green&#39;s functions at these points (\(\propto\ln(r)\) in 2D for \(\Delta f=0\)) (called <a href=https://en.wikipedia.org/wiki/Radial_basis_function>radial basis functions</a>) plus any harmonic function defined everywhere, \(H(x)\):</p><p>$$ f(\mathbf{x}) = H(\mathbf{x}) + \sum_{i=1}^N {c_i \ln(|\mathbf{x} - \mathbf{x}_i|)} $$</p><p>Let&#39;s think about minimizing the 1-bending, \(\int|f_x|^2 + |f_y|^2\). First of all, we probably want \(\sum_{i=1}^Nc_i\) to be zero, otherwise the derivatives of our basis functions don&#39;t cancel at infinity (which is obviously bad for minimzation). By the same logic, \(H(\mathbf{x})\) should also be bounded as \(r\rightarrow\infty\), but by <a href=https://en.wikipedia.org/wiki/Harmonic_function#Liouville&#39;s_theorem>Liouville&#39;s theorem</a>, that means it must be constant! So \(H(\mathbf{x})=c_0\) is a new unknown, but the constraint \(\sum_{i=1}^Nc_i=0\) helps resolve it. In the end, we can throw this mess in a matrix, and find all \(c_i\) by solving a linear equation.</p><h3 id=polyharmonic-splines>Polyharmonic Splines</h3><p>If you try what we did above with 2-bending and the biharmonic equation \(\Delta^2 f=0\), you&#39;ll find that the RBFs look like \(r^2 \ln(r)\), and that you have freedom up to linear functions. In general, \(m\)-bending minimization is free up to a degree \((m-1)\) polynomial, and the generalization of bending-minimizing functions subject to Dirichlet conditions at a finite set of points is called a &quot;polyharmonic spline&quot;. Now we can finally say:</p><p>A <strong>polyharmonic spline</strong> is a finite linear combination of specific radial basis functions \(\phi(|\mathbf{x}-\mathbf{x_i}|)\) and a polynomial term \(P(\mathbf{x})\): $$ f(\mathbf{x})=P(\mathbf{x}) + \sum_{i=1}^Nc_i\phi(|\mathbf{x}-\mathbf{x_i}|) $$ Where \(c_i\) and \(P\) are chosen so that \(f(\mathbf{x}_i)=y_i\) for all \(N\) interpolation centers \(\mathbf{x}_i\) and their values \(y_i\), and also so that \(f(x)\) minimizes the \(m\)-bending action of \(f\) defined earlier.</p><p>There are already good <a href=https://people.clarkson.edu/~gyao/paper/48.pdf>resources</a> <a href=https://en.wikipedia.org/wiki/Polyharmonic_spline#Definition>out</a> <a href=https://mathsfromnothing.au/polyharmonic-spline/ >there</a> describing how to actually <em>compute</em> \(\{c_i\}\) and \(P(x)\), but I haven&#39;t seen many informal posts describing where polyharmonic splines come from. Hopefully this post can help fill that gap!</p><p>But first, one last thought:</p><h3 id=thin-plate-splines-tps>Thin-Plate Splines (TPS)</h3><div class=imblock><img src=comparison.png class=postim></div>The function on the left minimizes 2-bending and solves the biharmonic equation. The function on the right minimizes 1-bending and solves the Laplace equation.<p>Which looks like a more &#39;natural&#39; interpolation choice?</p><p>For most applications, the one on the left! In fact, it looks so natural that 2-bending minimizing splines have a special name: <a href=https://en.wikipedia.org/wiki/Thin_plate_spline>thin plate splines</a>. It gets this name because &#39;minimize the 2-bending&#39; is roughly the rule that a thin sheet of metal would obey if it was being poked up and down in different places.</p><p>So, if you&#39;re ever trying to <a href=https://onlinelibrary.wiley.com/doi/10.1155/2018/3950312>interpolate between values scattered on a grid</a> (like I was before I wrote this), use a <a href=http://rodolphe-vaillant.fr/entry/57/2d-biharmonic-stencil-aka-bilaplacian-operator>biharmonic stencil</a>, not a 5-point Laplace.</p><h3 id=sources>Sources:</h3><ul><li><a href=https://en.wikipedia.org/wiki/Polyharmonic_spline>Polyharmonic Splines on Wikipedia</a></li><li><a href=https://www.stat.berkeley.edu/~ryantibs/statlearn-s24/lectures/tps_rkhs.pdf>Supplementary Notes: Representation of Thin-Plate Splines</a> (from Alden Green&#39;s <a href=https://www.stat.berkeley.edu/~ryantibs/statlearn-s24/ >spring 2024 course at Berkeley</a>, <em>Advanced Topics in Statistical Learning</em>)</li></ul><a href=./../../articles\Embedding\index.html class=button2 style=min-width:47%;>Previous Post:<br>Embedding the Shortest-Path Metric </a><a href=./../../articles\OvertureRoutingNetworks\index.html class=button2 style=min-width:47%;>Next Post:<br>Transportation Networks with Overture Maps Data (Notebook)</a></section><div id=footer></div></div></section></div></body></html>