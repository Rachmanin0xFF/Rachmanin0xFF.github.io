<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=format-detection content="telephone=no"><meta name=HandheldFriendly content=true><meta name=MobileOptimized content=320><meta name=viewport content="initial-scale=1,width=device-width"><title>Adam Lastowka - A Square FFT</title><meta name=description content=""><script async defer src=./../../scripts/parallax.js onload="var loaded=true;"></script><link rel=stylesheet id=lightmodehl href=./../../scripts/highlight/styles/atom-one-light.min.css><link rel=stylesheet id=darkmodehl href=./../../scripts/highlight/styles/hybrid.min.css disabled><script src=./../../scripts/highlight/highlight.min.js></script><script>hljs.highlightAll();</script><link rel=stylesheet href=./../../post.css><script defer src=./../../scripts/darkmode.js></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><link rel=icon href=./../../favicon.ico type=image/x-icon><link rel="shortcut icon" href=./../../favicon.ico type=image/x-icon></head><body><div id=bkg><section id=not-background><section id=sidebar><div class=sticky><div class="sb-big onbkg hvr-rotate"><a href=../../index.html>Home</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../about/index.html>About</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../qa/index.html>Q&A</a></div><!--<br><br><div id="dm-toggle" class="button sb-big hvr-rotate">Lights</button>--></div></section><section id=header><div class=null><div id=spikes class=vector alt=""></div></div><div id=sitename><h5><a href=./../../index.html>Adam<br>Lastowka</a></h5></div></section><div id=foreground><section id=feed><h1>A Square FFT</h1><div class=date>Published: May 7, 2023</div><div class=tags>Tagged with: <a href=./../../topics/cs/index.html>cs</a> <a href=./../../topics/math/index.html>math</a> <a href=./../../topics/signals/index.html>signals</a></div><br><h2 id=introduction>Introduction</h2><p>I recently indulged in the &quot;pleasure&quot; of writing my own implementation of the <a href=https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case>Cooley-Tukey radix-2 DIT fast Fourier transform (FFT)</a> for AVR microcontrollers. Despite the immeasurable fun I had scratching my head over bit-twiddling and fixed-point multiplication bugs, I wasn&#39;t writing the library for its own sake. The final project for my intro EE course was in basic signal processing:</p><div class=imblock><img src=emtproject.png class=postim>The cute little circuit I designed for my "Electronic Measurement Techniques" class.</div><p>Our grade was dependent on how quickly and accurately we could identify different frequencies in an input signal. I looked around at available Arduino FFT libraries and quickly decided I wanted to try making my own. In the process, I stumbled across a silly, inaccurate, surprisingly effective alternative to the traditional FFT. I&#39;ll provide a quick refresher on Fourier transforms, then jump into other strategies.</p><h3 id=background>Background</h3><p>The fast Fourier transform (FFT) is among the most important and widely-used algorithms ever created. The process is so universally effective that it is even applicable to <a href=https://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm><em>multiplication</em></a>. Ultimately, it is just a divide-and-conquer method for calculating the <strong>discrete Fourier transform (DFT)</strong>. The DFT is much easier to understand and has a wonderful visual interpretation. Consequently, there are many online videos and articles explaining it.</p><p>IMO, the best of these was created five years ago by the exceptional math YouTuber Grant Sanderson (a.k.a. <a href=https://www.youtube.com/@3blue1brown>3Blue1Brown</a>), who published a <a href="https://www.youtube.com/watch?v=spUNpyF58BY">wonderful video</a> on the Fourier Transform. I won&#39;t repeat his explanation in detail (watch the video!), but a Fourier transform works via &quot;spinning&quot; your input signal around in a circle. If the frequency of the spinning matches a frequency in the signal, the resulting pattern will be lopsided, and the amount of lopsided-ness represents the intensity of that frequency in the signal.</p><p>When working symbolically, Fourier transforms are relatively easy to compute; we define the Fourier transform of a signal \(f(x)\) as follows (I will neglect normalization coefficients in this article):</p><p>\[ F(s):=\int_{-\infty}^\infty f(x) e^{-2\pi i s x} dx \]</p><p>This is a lovely equation (infinite limits make for easy integrals), but in practice, it fails: what if we want to take the Fourier Transform of a discrete time series, like an audio signal? We can&#39;t let our limits go to infinity, and our continuous integral needs to be replaced with something more appropriate for computers. Enter the <strong>discrete Fourier transform</strong> (DFT). For a series \(f=f_0, f_1, f_2, \ldots, f_{N-1}\):</p><p>\[ F(k):=\sum_{j=0}^{N-1}f_j e^{-2\pi i \frac{kj}{N}} \]</p><p>The logic behind this transform is identical to its continuous analog, but now we can actually write a program to compute it. If it helps, you can think of the DFT as a kind of Riemann sum approximation of the full Fourier transform.</p><p>Unfortunately, calculating the DFT with a naive sum is very slow. Specifically, computing \(K\) DFT bins from \(N\) input samples is of complexity \(O(KN)\), or \(O(N^2)\) if \(K=N\). The FFT brings this down to \(O(N \log N)\) by using the fact that <em>merging</em> two DFTs is only \(O(N)\).</p><h2 id=speed>Speed</h2><p>The real operation cost of any FFT comes from the calculation of the phase factors <a href=https://en.wikipedia.org/wiki/Twiddle_factor>(twiddle factors)</a>. These essentially amount to computing \(e^{i\theta}\), or \(\sin\theta\) and \(\cos\theta\) for some fixed set of values. Typically, these operations are either precalculated or interpolated from a lookup table (LUT). Combine this with some well-placed bit shifting, and we are now faced with a new bottleneck: the cost of multiplying the twiddle factors by the signal.</p><p>Admittedly, I was writing in C, not ASM, so there were certainly other, more direct avenues for optimization before trying to shave off a few clock cycles lost to multiplication. But I was curious: what if I could avoid multiplication altogether?</p><p>Remember how I mentioned that a Fourier transform spins a signal around in a circle?</p><div class=imblock><img src=circle.gif class=postim></div><p>What if instead, we spin it around in a <em>square</em>?</p><div class=imblock><img src=box.gif class=postim>Okay, this isn't really a square, it's eight points in a square-like pattern. To make a true square shape, you would need to replace your sinusoids with truncated/clamped triangle waves. For lack of a better name, I'll still call it a "square" in this article.</div><p>This sounds kind of stupid, but the advantage is that (when properly implemented) it can be quite fast. Multiplying by this sort of wave actually doesn&#39;t have to involve an IMUL operation at all; you only need to do one of three things for each axis:</p><ol><li>Set the number to zero (multiply by 0)</li><li>Negate the number (multiply by -1)</li><li>Leave the number unchanged (multiply by 1)</li></ol><p>Determining <em>where</em> along the signal these things need to happen can slow things down, but the operations themselves are all very fast. Note that these waves are not quite square waves: their range also includes zero.</p><h2 id=distortion>Distortion</h2><p>Crudely approximating \(\sin()\) and \(\cos()\) like this inevitably leads to some artifacts in the output spectrum. Where the DFT of a pure sine wave would show a single spike at the correct frequency, the &quot;square&quot; approximation contains (sub)harmonic artifacts:</p><div class=imblock><img src=squarefftspec.png class=postim></div><p>Let&#39;s a lot of these graphs and squish them into a picture to get an idea of the artifact intensity w.r.t. input frequency.</p><div class=imblock><img src=fig1.png class=postim>The input signals for these spectra include random phase offsets, moderate sub-bin frequency variations, and background white noise (at 5% signal strength) -- I figured I'd make it a fair fight. Colors use a log scale.</div><p>Definitely worse, but not too bad! It&#39;s difficult to see in the log scale, but the strongest artifacts in the square DFT are still under 25% of the true peak diagonal. The performance is usually good enough to identify a few sinusoidal frequencies of similar magnitudes (which was, incidentally, exactly what my EE project required).</p><p>Also, just for kicks, here&#39;s another version using a triangle wave:</p><div class=imblock><img src=triangle.png class=postim>This amounts to wrapping your signal around the complex plane in a diamond shape.</div><h2 id=interpretation>Interpretation</h2><p>The wonderful thing about Fourier analysis that it isn&#39;t specific to sines and cosines. The \(e^{i\theta}\) basis is used for convenience mathematics and physics, but Fourier decomposition never requires it. In fact, given <em>any</em> complete set of basis functions \( {g_1, g_2, g_3, \ldots} \) we can always find coefficients such that any arbitrary function in Hilbert space \( f(x) \) can be represented as as:</p><p>\[ f(x) = \sum_j^\infty c_j g_j(x)\]</p><p>If our basis functions are orthogonal (no \(g_j\) can be written as the sum of products of other \(g\)s) and normal (the integral of \(|g_j|^2=1\)) then we can find these coefficients using the same integral we used for our Fourier transform (the <strong>inner product</strong> of \(f\) and \(g_j\)):</p><p>\[ c_j = \int_{-\infty}^{\infty} f(x) g_j(x) dx = \langle f, g_j \rangle \]</p><p>When \(g_0(x)=\sin(x), g_1(x)=\sin(2x), g_3(x)=\sin(3x),\ldots\), we call our sum a Fourier (sine) series. When \(g_j(x)\) are small digital blips, we call it a <a href=https://en.wikipedia.org/wiki/Haar_wavelet>Haar wavelet transform</a>. Each different choice of our \({g_j}\), our <strong>basis</strong>, has its own unique applications and use cases.</p><p>The &quot;square&quot; sinusoids I used here are just another basis in Hilbert space. The &quot;artifacts&quot; that appeared in my signals were there because the DFT wasn&#39;t decomposing my signal into sinusoids, it was decomposing it into a basis of pseudo-square waves. The real advantage of using the sine/cosine/circle basis is that the amplitude of a signal is independent of its phase angle, but this is not necessarily guaranteed for other bases (squares are not radially symmetric).</p><h2 id=conclusion>Conclusion</h2><p>It&#39;s easy to think of FFT libraries as magical black boxes that spit out spectra and phase information. Most of the time, this is perfectly acceptable. But occasionally, limited hardware, speed requirements, or some very specific problem will necessitate the use of a different basis (often <a href=https://en.wikipedia.org/wiki/Discrete_wavelet_transform>wavelets</a> or a <a href=https://en.wikipedia.org/wiki/Discrete_cosine_transform>DCT</a>). Sometimes, it&#39;s hip to be square! :]</p></section><div id=footer></div></div></section></div></body></html>