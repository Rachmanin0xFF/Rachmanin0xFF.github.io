<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=format-detection content="telephone=no"><meta name=HandheldFriendly content=true><meta name=MobileOptimized content=320><meta name=viewport content="initial-scale=1,width=device-width"><title>Adam Lastowka - Motivation for Polyharmonic Splines</title><meta name=description content=""><script async defer src=./../../scripts/parallax.js onload="var loaded=true;"></script><link rel=stylesheet id=lightmodehl href=./../../scripts/highlight/styles/atom-one-light.min.css><link rel=stylesheet id=darkmodehl href=./../../scripts/highlight/styles/hybrid.min.css disabled><script src=./../../scripts/highlight/highlight.min.js></script><script>hljs.highlightAll();</script><link rel=stylesheet href=./../../post.css><script defer src=./../../scripts/darkmode.js></script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><link rel=icon href=./../../favicon.ico type=image/x-icon><link rel="shortcut icon" href=./../../favicon.ico type=image/x-icon></head><body><div id=bkg><section id=not-background><section id=sidebar><div class=sticky><div class="sb-big onbkg hvr-rotate"><a href=../../index.html>Home</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../about/index.html>About</a></div><br><div class="sb-big onbkg hvr-rotate"><a href=../../qa/index.html>Q&A</a></div><!--<br><br><div id="dm-toggle" class="button sb-big hvr-rotate">Lights</button>--></div></section><section id=header><div class=null><div id=spikes class=vector alt=""></div></div><div id=sitename><h5><a href=./../../index.html>Adam<br>Lastowka</a></h5></div></section><div id=foreground><section id=feed><h1>Motivation for Polyharmonic Splines</h1><div class=date>Published: Jan 6, 2025</div><div class=tags>Tagged with: <a href=./../../topics/math/index.html>math</a> <a href=./../../topics/cs/index.html>cs</a></div><br><p>I have a 9x9 grid of numbers; I only know what three of them are.</p><p>Can we guess the other numbers in the grid given these three?</p><p>...</p><p>Okay, obviously, no, we can&#39;t. We need some additional information. Maybe that information is &quot;this is a sudoku board&quot;, or &quot;everything else is just 5&quot;. I&#39;ll pick a simple-sounding rule:</p><p><strong>Every remaining number is the average of its neighbors.</strong></p><p>Where &quot;neighbors&quot; doesn&#39;t include cells on diagonals (just the four cardinal directions). This rule is great because it&#39;s really easy to solve with a computer. We just do this:</p><pre><code class=language-python>for i in range(0, iterations):
    for each cell:
        cell = average(cell_neighbors)
</code></pre><div class=imblock><img src=anim-squares1.gif class=postim></div><p>This code is guaranteed to stabilize at a solution. I won&#39;t get into <em>why</em> here, but it&#39;s not very hard to intuit from the visualization above. It seems like we&#39;re <strong>smoothing out</strong> the grid of numbers until we reach something maximally smooth, in some sense.</p><p>Okay, but what does &quot;maximally smooth&quot; mean? Can we define it?</p><h3 id=stencils>Stencils</h3><p>&quot;Update cell (x, y) to be the average of its neighbors&quot; really means: $$ f_{i+1}(x, y)=\frac{1}{4}\left(f_i(x+1, y) + f_i(x-1, y) + f_i(x, y+1) + f_i(x, y-1)\right) $$ <strong>At stability</strong>, we expect that \(f_{i+1}=f_i\), so we can drop the \(i\), subtract \(f(x, y)\) from both sides, and multiply by -4: $$ 0 = 4f(x, y) - f(x+1, y) - f(x-1, y) - f(x, y+1) - f(x, y-1) $$ We can draw this as a <a href=https://en.wikipedia.org/wiki/Stencil_(numerical_analysis)>stencil</a> for convenience:</p><div class=imblock><img src=stencil.png class=postim></div><p>If you&#39;ve worked with <a href=https://pythonnumericalmethods.studentorg.berkeley.edu/notebooks/chapter23.03-Finite-Difference-Method.html>finite difference methods</a> before, you might recognize this as the stencil for the Laplace equation, \(\Delta f=0\). That&#39;s right: $$ \textrm{&quot;Be the average of your neighbors&quot;} \approx (\textrm{Solve }\Delta f = 0) $$ If you want to know <em>why</em> this is true, you can <a href=https://mitchr.dev/2020/03/18/skewedLaplaceSquare.html>derive it</a> by taking a Taylor expansion at each node, but I also encourage you think through things before plugging in symbols. A few things to mull over:</p><ul><li>The second derivative of a 1D function answers the question &quot;how much am I different from the average of my neighbors?&quot; at each point.</li><li>For the 2D Laplace operator, bending along one axis cancels bending along the other.</li><li>The Laplace equation essentially says &quot;no local extrema allowed!&quot;</li></ul><p>Anyhow, the gist is that differential operators have (non-unique) <strong>stencils</strong> associated with them. It turns out the simple little algorithm we wrote above is equivalent to solving a 9x9 discretization of the Laplace equation via the <a href=https://en.wikipedia.org/wiki/Jacobi_method>Jacobi method</a>.</p><p>Okay, but what about &quot;maximal smoothness&quot;? Are the solutions to the Laplace Equation maximally smooth, somehow?</p><p><em>Note: I&#39;m not talking about <a href=https://en.wikipedia.org/wiki/Smoothness>smoothness</a> in the traditional mathematical sense, I mean something closer to &quot;smooth to the touch&quot;. Also, we&#39;re about to get a little mathematical, so be warned: I am not a mathematician :P (we will keep it very informal)</em></p><h3 id=quantifying-bending>Quantifying Bending</h3><p>Instead of thinking about maximal smoothness, let&#39;s work in terms of the equivalent property, &#39;minimal roughness&#39;. Let&#39;s also think generally, in \(d\) dimensions.</p><p><strong>To determine how &#39;rough&#39; (not-smooth) a function is, we&#39;ll add up the amount of bending happening on it.</strong> Let&#39;s focus on derivatives. We&#39;ll use the operator \(\nabla^m\), which spits out a vector of all \(m\)th-order partial derivatives, e.g. \(\nabla^2 f = (f_{xx},f_{xy},f_{yx},f_{yy})\) in 2D. I&#39;ll call the quantity \(|\nabla^m f|^2\) the &quot;\(m\)-bending&quot; of \(f\) (rough-feeling \(\implies\) lots of bending). So, in 2D, the 2-bending of \(f\) is: $$ |\nabla^2 f|^2={f_{xx}}^2 + {f_{xy}}^2 + {f_{yy}}^2 $$ And its 1-bending is simply: $$ |\nabla f|^2={f_{x}}^2+ {f_{y}}^2 $$ We can talk about the <em>total</em> \(m\)-bending on \(f\) by integrating this value: $$ E[f]=\int_{\Omega \subset \mathbb{R}^d} |\nabla^m f|^2 d\mathbf{x} $$ Here, \(d\mathbf{x}\) is hypervolume (a bit of our region, \(\Omega\)) and \(E\) is a functional. So if some \(f\) minimizes this functional (a function of a function), we can say it has the sort of &#39;minimal roughness&#39; we were looking for.</p><h3 id=from-action-to-local-laws>From Action to Local Laws</h3><p>The <a href=https://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation>Euler-Lagrange equations</a> let us translate statements about maximization into digestible, practical equations. Let&#39;s try using them here and see what comes out. The relevant one for our problem looks like this: $$ \frac{\partial E}{\partial f} - \sum_{i}^d (-1)^{|\alpha_i|}\partial^{\alpha_i}\frac{\partial F}{\partial(\partial^{\alpha_i}f)} = 0 $$ To get everything in the right form, \(E[f]\) can be written in terms of a Lagrangian, \(F\): $$ E[f] = \int_{\Omega \subset \mathbb{R}^d}F(\partial^{\alpha_1}f,\partial^{\alpha_2}f,\ldots,\partial^{\alpha_d}f) $$ Where \(\alpha_i\) multi-indexes \(m\)th-order partial derivatives. Because this functional only depends on the partial derivatives of \(f\) and not \(f\) itself, \(\partial F / \partial f\) = 0, and we just need to find the quantity: $$ \sum_{i}^d\partial^{\alpha_i}\frac{\partial F}{\partial (\partial^{\alpha_i}f)}=\sum_{i}^d\partial^{\alpha_i}\frac{\partial |\nabla^mf|^2}{\partial (\partial^{\alpha_i}f)}=2\sum_{i}^d(\partial^{\alpha_i})^2f=2\nabla^{2m}f=2\Delta^m f $$ Plugging this into the appropriate Euler-Lagrange equation, all that remains is: $$ \Delta^m f = 0 $$ So our energy-minimizing \(f\) solves a <a href=https://encyclopediaofmath.org/wiki/Poly-harmonic_function>polyharmonic equation</a>. For us, this means that if a function \(g:\mathbb{R}^2\to \mathbb{R}\) minimizes \({g_{x}}^2 + {g_{y}}^2\) integrated over its surface, then \(g\) <strong>solves the Laplace equation</strong> \(\Delta^2 g = \nabla g = 0\).</p><p>However, this does not necessarily mean that the converse is true: <strong>we still don&#39;t know if our averaging algorithm generates maximally-smooth grids!</strong></p><h3 id=trouble-at-the-boundaries>Trouble at the Boundaries</h3><p>The problem that I&#39;ve danced around until now is that I never explicitly said what happens at the <em>borders</em> of the 9x9 square: I worded the rule in a way that implied only <em>existing</em> neighbors were considered in the average. I did specify a <em>few</em> boundary conditions (the three Dirichlet points on the grid), but these don&#39;t tell you anything about the edges.</p><p>Keep in mind that I could&#39;ve done anything else. Cells could have been surrounded by a border of fixed values (<a href=https://en.wikipedia.org/wiki/Dirichlet_boundary_condition>Dirichlet</a> bounds), restricted to be &quot;flat&quot; or &quot;sloped&quot; at the edges (<a href=https://en.wikipedia.org/wiki/Neumann_boundary_condition>Neumann</a> bounds), or any other choice from the uncountably infinite set of possible boundary conditions (BCs). Some of these boundaries will lead to very slope-y behavior, so we can say that <strong>not all BCs will lead to minimal bending</strong>.</p><p>But if we want minimal bending, which BCs do we choose?</p><p>We could just <em>search</em> the space of possible BCs. Bending is computable (and, notably, a linear function of the cell values) on the 9x9 grid; throwing an optimizer at it should work. For higher-order polyharmonics with larger stencils, you can pad the boundary with additional cells.</p><p>However, if we ask about the bending on <em>all</em> of \(\mathbb{R}^d\), there&#39;s an easier option.</p><h3 id=free-variables>Free Variables</h3><p>Let&#39;s return to the 2D Laplace equation for an illustrative example. In our case, we&#39;re looking at weakly <a href=https://en.wikipedia.org/wiki/Harmonic_function>harmonic</a> solutions with singularities at the \(N=3\) points we fixed, which I&#39;ll denote \( \mathbf{x}_1, \mathbf{x}_2, \cdots, \mathbf{x}_N \). If these are the <em>only</em> singularities we have, we expect the solution to be some linear combination of the Green&#39;s functions at these points (\(\propto\ln(r)\) in 2D for \(\Delta f=0\)) plus any <a href=https://en.wikipedia.org/wiki/Entire_function>entire</a> harmonic function, \(H(x)\):</p><p>$$ f(\mathbf{x}) = H(\mathbf{x}) + \sum_{i=1}^N {c_i \ln(|\mathbf{x} - \mathbf{x}_i|)} $$</p><p>Let&#39;s think about minimizing \(\int|f_x|^2 + |f_y|^2\). First of all, we probably want \(\sum_{i=1}^Nc_i\) to be zero. Otherwise, we&#39;re left with some amount of \(\ln(|\mathbf{x}|)\) that we can&#39;t &#39;cancel&#39; with \(H(\mathbf{x})\) as \(r\rightarrow\infty\) (we&#39;d need another opposing singularity).</p><p>By the same logic, \(H(\mathbf{x})\) should also be bounded as \(r\rightarrow\infty\), but by <a href=https://en.wikipedia.org/wiki/Harmonic_function#Liouville&#39;s_theorem>Liouville&#39;s theorem</a>, that means it must be constant! So \(H(\mathbf{x})=c_0\), and that becomes the free variable required to ensure \(\sum_{i=1}^Nc_i=0\). In the end, we can throw all of this in a matrix, and find all \({c_i}\) by solving a linear equation.</p><h3 id=polyharmonic-splines>Polyharmonic Splines</h3><p>If you try what we did above with 2-bending and the biharmonic equation \(\Delta^2 f=0\), you&#39;ll find that the Green&#39;s functions look like \(r^2 \ln(r)\), and that you have freedom up to linear functions. In general, \(m\)-bending minimization is free up to a degree \((m-1)\) polynomial, and the generalization of bending-minimizing functions subject to Dirichlet conditions at a finite set of points is called a &quot;polyharmonic spline&quot;.</p><p>A <strong>polyharmonic spline</strong> is a finite linear combination of radial basis functions \(\phi(|\mathbf{x}-\mathbf{x_i}|)\) and a polynomial term \(P(\mathbf{x})\): $$ f(\mathbf{x})=P(\mathbf{x}) + \sum_{i=1}^Nc_i\phi(|\mathbf{x}-\mathbf{x_i}|) $$ Where \(c_i\) and \(P\) are chosen so that \(f(\mathbf{x}_i)=y_i\) for all \(N\) interpolation centers \(\mathbf{x}_i\) and their values \(y_i\), and also so that \(f(x)\) minimizes the \(m\)-bending action of \(f\) defined earlier.</p><p>There are already good <a href=https://people.clarkson.edu/~gyao/paper/48.pdf>resources</a> <a href=https://en.wikipedia.org/wiki/Polyharmonic_spline#Definition>out</a> <a href=https://mathsfromnothing.au/polyharmonic-spline/ >there</a> describing how to actually <em>compute</em> \({c_i}\) and \(P(x)\), but I haven&#39;t seen many informal posts describing where polyharmonic splines come from. Hopefully this post can help fill that gap!</p><p>But first, one last thought:</p><h3 id=thin-plate-splines-tps>Thin-Plate Splines (TPS)</h3><div class=imblock><img src=comparison.png class=postim></div>The function on the left minimizes 2-bending and solves the biharmonic equation. The function on the right minimizes 1-bending and solves the Laplace equation.<p>Which looks like a more &#39;natural&#39; interpolation choice?</p><p>For most applications, the one on the left! In fact, it looks so natural that 2-bending minimizing splines have a special name: <a href=https://en.wikipedia.org/wiki/Thin_plate_spline>thin plate splines</a>. It gets this name because &#39;minimize the 2-bending&#39; is roughly the law that a thin sheet of metal would obey if it was being poked up and down in different places.</p><p>So, if you&#39;re ever trying to <a href=https://onlinelibrary.wiley.com/doi/10.1155/2018/3950312>interpolate between sparse values scattered on a grid</a> (like I was before I wrote this), use a <a href=http://rodolphe-vaillant.fr/entry/57/2d-biharmonic-stencil-aka-bilaplacian-operator>biharmonic stencil</a>, not a 5-point Laplace.</p><h3 id=sources>Sources:</h3><ul><li><a href=https://en.wikipedia.org/wiki/Polyharmonic_spline>Polyharmonic Splines on Wikipedia</a></li><li><a href=https://www.stat.berkeley.edu/~ryantibs/statlearn-s24/lectures/tps_rkhs.pdf>Supplementary Notes: Representation of Thin-Plate Splines</a> (from Alden Green&#39;s <a href=https://www.stat.berkeley.edu/~ryantibs/statlearn-s24/ >spring 2024 course at Berkeley</a>, <em>Advanced Topics in Statistical Learning</em>)</li></ul><a href=./../../articles\OvertureRoutingNetworks\index.html class=button2 style=min-width:47%;>Next Post:<br>Transportation Networks with Overture Maps Data (Notebook)</a></section><div id=footer></div></div></section></div></body></html>